

detect dead areas, areas where your opponent has limited you to one corner or two sides and no rings
- negative knowledge?
- really dead (completely enclosed) vs almost/temporarily dead (enclosed with VCs)?

do 2 ply search at node initialization if certain conditions are met
- 1 corner and group size >= board size - 1
- 2 edges and group size >= board size + 1
- ring  if group size >= 5

build a linked list of empty moves so the move iterator can skip filled moves


multi-thread
- generally lockless
- allow ponder?
- virtual loss to encourage exploration
- race conditions:
  - minimax backup
    - select a move, it's proven a loss, then back it up as a loss, though it was just a bad move selection
    - prove a node while another thread is down that node, can't remove until all threads are back up
      - just don't delete nodes?
      - reference count?
  - depth stats
    - use thread context?
- different parameters (ie ravefactor) for each player thread?
  - useful for testing parameters at different parts of the game


share the tree between the player and solver
- add phi/delta to UCTNode
- need way of knowing whether the node has been initialized by the player or solver
- how to deal with areas of the tree that are initialized by the other?
- rave updates for parts of the tree that aren't yet initialized?
- phi/delta as knowledge again?
- thread safety?
- run multiple different solvers? dfpnsab/pnsab


avoid symmetry for the first 3-5 moves, or just build an opening book

detect frames?

prior knowledge
- criticality
- copy knowledge from proof tree
- store knowledge as rave experience instead of real experience?
- size of group

rollout policy
- use weighted random choices instead of uniform random:
- different weights for black vs white?
- local reply?
- locality?
- connections?
- avoid loss
  - use null move to make this equal to force win
  - use locality to stop checking moves that are near nothing


Time control
- quiecense search - if the highest winrate != most played, keep simulating until it is
- if only one move doesn't lose, stop simulating and just make that move
  - good idea with total time per game, but not per move


