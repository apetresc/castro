

if only one move doesn't lose, stop simulating and just make that move
- this is a good idea with total time per game, but not per move

rave weight according to rollout length?
- give weight based on how many standard deviations this rollout is from the average
- need num to be a float then, which may cause issues...


multi-thread
- generally lockless
- allow ponder?
- virtual loss to encourage exploration
- race conditions:
  - minimax backup
    - select a move, it's proven a loss, then back it up as a loss, though it was just a bad move selection
    - prove a node while another thread is down that node, can't remove until all threads are back up
      - just don't delete nodes?
  - depth stats


GTP server
- listen on an ip/port
- spawn a child on connect, connecting stdin/stdout to the connection
- inetd?

Test
- longer games
- different rave functions
- set a new baseline
- rave extensions


detect frames?

prior knowledge
- criticality
- copy knowledge from proof tree

rollout policy
- use weighted random choices instead of uniform random:
- different weights for black vs white?
- local reply?
- locality?
- connections?
- avoid loss?

Time control
- quiecense search - if the highest winrate != most played, keep simulating until it is


