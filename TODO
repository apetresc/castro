

if only one move doesn't lose, stop simulating and just make that move
- this is a good idea with total time per game, but not per move

rave weight according to rollout length?
- give weight based on how many standard deviations this rollout is from the average
- need num to be a float then, which may cause issues...


multi-thread
- generally lockless
- allow ponder?
- virtual loss to encourage exploration
- race conditions:
  - minimax backup
    - select a move, it's proven a loss, then back it up as a loss, though it was just a bad move selection
    - prove a node while another thread is down that node, can't remove until all threads are back up
      - just don't delete nodes?
  - depth stats

Test
- longer games
- different rave functions
- set a new baseline
- rave extensions

avoid symmetry for the first 3-5 moves, or just build an opening book

detect frames?

prior knowledge
- criticality
- copy knowledge from proof tree
- forced moves
  - test for wins, then test for losses, essentially 1 ply negamax
  - if only one move doesn't lose, give it real experience to make a "macro move" and keep playing this simulation
- store knowledge as rave experience instead of real experience?

rollout policy
- use weighted random choices instead of uniform random:
- different weights for black vs white?
- local reply?
- locality?
- connections?
- avoid loss?

Time control
- quiecense search - if the highest winrate != most played, keep simulating until it is


