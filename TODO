
worker stuff
- PS1='\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
- cd /tmp; wget -N --no-check-certificate https://dropbox.ewalds.ca/worker.sh; screen -d -m sh worker.sh; logout


progressive widening
- start at one child
- add an extra move after 1.5x as many rollouts
- implement as looking at the first log(children)/log(1.5) of the children


multiple rollouts per simulation
- combine rave updates, lower contention
- also allow children to be stored out of order so progressive widening will work
- GPU rollouts for those that don't care about rings?

solvers need knowledge for move ordering


fix crash after last move

batch update for the first couple moves to speed up backups

move ordering by knowledge
- lower bound on distance to edges/corners
- maybe based on number of paths? handles virtual connections



reimplement O(1) ring detection
- pattern for the normal case
- only search for a 6 ring for the blob case

garbage collect the player

rework swap
- rave doesn't give swap any time, so useless as a searchable move
- swap can't be changed after ponder is enabled
- waste of time anyway
- crashes when swap isn't a valid move
- new way:
  - only handle in the opening book?
  - maximize over min(exp, 1-exp) on empty board
  - swap if exp < 0.5 after first move

should the PNSTT solver use a LRU hash table?

Merge the solvers
- alpha-beta would benefit from the transposition table
- Two node types: NodeTree, NodeTT
- any point in keeping the heap based version?
- needs a way of running in the background
- run in parallel to player


do proven nodes need
- rave updates?
- to be considered in move choice?
- can this be improved by sorting nodes:
  - solved win
  - unsolved, sorted by x,y
  - solved ties
  - solved losses
- how to do this multi-threaded?


detect dead areas, areas where your opponent has limited you to one corner or two sides and no rings
- negative knowledge?
- really dead (completely enclosed) vs almost/temporarily dead (enclosed with VCs)?
- still useful to block opponent wins?
- may be related to lower bound on win?

do 2 ply search at node initialization if certain conditions are met
- 1 corner and group size >= board size - 1
- 2 edges and group size >= board size + 1
- ring if group size >= 5
- how to interact with lower bound?

build a linked list of empty moves so the move iterator can skip filled moves
- probably not worth it since the iterator is used so rarely
- could build a doubly linked list since memory in this area is cheap
- more expensive in the solver than the player

final move selection
- what to do when the node with the most work is solved as a loss, but there is an unsolved node with little experience
  - might be an easy win for the opponent
  - take extra time if possible
- fast wins
- slow loss/ties


multi-thread
- different parameters (ie ravefactor) for each player thread?
  - useful for testing parameters at different parts of the game


share the tree between the player and solver
- add phi/delta to UCTNode
- need way of knowing whether the node has been initialized by the player or solver
- how to deal with areas of the tree that are initialized by the other?
- rave updates for parts of the tree that aren't yet initialized?
- phi/delta as knowledge again?
- thread safety?
- run multiple different solvers? dfpnsab/pnsab
- knowledge for phi/delta

avoid symmetry for the first 3-5 moves, or just build an opening book

detect frames?

prior knowledge
- criticality
- copy knowledge from proof tree
- locality for friendly stones only
- avoid clumping? penalty for being near many of your own stones
- lower bound needs virtual connection bonus / penalty for crossing opponents VC

rollout policy
- use weighted random choices instead of uniform random:
- different weights for black vs white?
- local reply?
- locality?
- connections?


Time control
- quiecense search - if the highest winrate != most played, keep simulating until it is
- if only one move doesn't lose, stop simulating and just make that move
  - good idea with total time per game, but not per move


