
worker stuff
- PS1='\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
- cd /tmp; wget -N --no-check-certificate https://dropbox.ewalds.ca/worker.sh; screen -d -m sh worker.sh; logout

player solver size 4:
- LD_PRELOAD="/usr/lib/libtcmalloc.so"
- boardsize 4
- player_params -g 1 -P 1 -t 12 -M 15000 -o 1


switch to 64 bit exp values?
log, then prune solved nodes
solver threads should use a TT instead of using the tree?

progressive widening
- start at one child
- add an extra move after 1.5x as many rollouts
- implement as looking at the first log(children)/log(1.5) of the children

if not keeptree, and the number of non-losing moves at the root is 1, just make that move

any ideas to handle ladders?
- always generate threats?

reuse (partial?) proof trees
- if a move is backed up as a win, it is likely a win under its siblings too
- give it a bonus to its equivalent cousins
- can we try to prove siblings by reusing the proof tree?

Test the accuracy of the rollouts
- do a tree search to get a value of a position
- run 1000 rollouts without a tree search to get the value of the position
- compare the two for many positions
- compare at various stages in a game
- test different rollout policies to minimize error

multiple rollouts per simulation
- combine rave updates, lower contention
- also allow children to be stored out of order so progressive widening will work
- GPU rollouts for those that don't care about rings?


fix crash after last move

batch update for the first couple moves to speed up backups
- don't bother updating rave at all if the num experience > something big


move ordering by knowledge
- lower bound on distance to edges/corners
- maybe based on number of paths? handles virtual connections


reimplement O(1) ring detection
- pattern for the normal case
- only search for a 6 ring for the blob case

rework swap
- rave doesn't give swap any time, so useless as a searchable move
- swap can't be changed after ponder is enabled
- waste of time anyway
- crashes when swap isn't a valid move
- new way:
  - only handle in the opening book?
  - maximize over min(exp, 1-exp) on empty board
  - swap if exp < 0.5 after first move

do proven nodes need
- rave updates?
- to be considered in move choice?
- can this be improved by sorting nodes:
  - solved win
  - unsolved, sorted by x,y
  - solved ties
  - solved losses
- how to do this multi-threaded?


detect dead areas, areas where your opponent has limited you to one corner or two sides and no rings
- negative knowledge?
- really dead (completely enclosed) vs almost/temporarily dead (enclosed with VCs)?
- still useful to block opponent wins?
- may be related to lower bound on win?

do 2 ply search at node initialization if certain conditions are met
- 1 corner and group size >= board size - 1
- 2 edges and group size >= board size + 1
- ring if group size >= 5
- how to interact with lower bound?

build a linked list of empty moves so the move iterator can skip filled moves
- probably not worth it since the iterator is used so rarely
- could build a doubly linked list since memory in this area is cheap
- more expensive in the solver than the player

final move selection
- what to do when the node with the most work is solved as a loss, but there is an unsolved node with little experience
  - might be an easy win for the opponent
  - take extra time if possible
- fast wins
- slow loss/ties


multi-thread
- different parameters (ie ravefactor) for each player thread?
  - useful for testing parameters at different parts of the game


share the tree between the player and solver
- add phi/delta to UCTNode
- need way of knowing whether the node has been initialized by the player or solver
- how to deal with areas of the tree that are initialized by the other?
- rave updates for parts of the tree that aren't yet initialized?
- phi/delta as knowledge again?
- thread safety?
- run multiple different solvers? dfpnsab/pnsab
- knowledge for phi/delta

avoid symmetry for the first 3-5 moves, or just build an opening book

detect frames?

prior knowledge
- criticality
- copy knowledge from proof tree
- locality for friendly stones only
- avoid clumping? penalty for being near many of your own stones
- lower bound needs virtual connection bonus / penalty for crossing opponents VC

rollout policy
- use weighted random choices instead of uniform random:
- different weights for black vs white?
- local reply?
- locality?
- connections?


Time control
- quiecense search - if the highest winrate != most played, keep simulating until it is
- if only one move doesn't lose, stop simulating and just make that move
  - good idea with total time per game, but not per move



Pros of MCTS:
- very general heuristic
- doesn't get lost
- uses previous experience
- easy parallelization

Cons of MCTS:
- slow
- memory heavy
- magic and witchcraft relates to both the exploration factor, as well as developing good simulation policies/patterns.

Pros of PNS:
- game independent
- works well when branching factor is important
- independent of position in the tree, so fast
- different

Cons of PNS:
- linear decay instead of exponential decay
- gets lost since branching factor is very short sighted
- doesn't use much knowledge or past experience


PNS based:
- Add heuristic knowledge:
  - random rollouts as knowledge?
- Keep knowledge for future move selection
- expected win value of a node, then minimize (delta*(1-value))
- take amount of work into account in move selection
- maximize the expected increase of: 1/p2 + 1/d2

MCTS based:
- maintain phi/delta, and add them as an exploration criteria to the UCT formula
- Add thresholds so updates don't need to go all the way to the root
- change updates so it's not a complete weighted average
  - do minimax backup
  - weighted average ignoring solved nodes
  - weighted average over the best 50% of work

Hybrid:
- have a few threads start with MCTS, then switch to PNS at some point:
  - once the branching factor is not uniform amoung siblings
  - once the node has fewer than some amount of simulations
  - once valuation is polarized (ie 60%+ or 40%-)
- have a few threads watching a work queue
- share a tree
  - some threads doing each, both expanding and proving nodes
  - threads switch between proof and player based on success


