

do 2 ply search at node initialization if certain conditions are met
- 1 corner and group size >= board size - 1
- 2 edges and group size >= board size + 1
- ring  if group size >= 5

build a linked list of empty moves so the move iterator can skip filled moves

if only one move doesn't lose, stop simulating and just make that move
- this is a good idea with total time per game, but not per move

rave weight according to rollout length?
- give weight based on how many standard deviations this rollout is from the average
- need num to be a float then, which may cause issues...


multi-thread
- generally lockless
- allow ponder?
- virtual loss to encourage exploration
- race conditions:
  - minimax backup
    - select a move, it's proven a loss, then back it up as a loss, though it was just a bad move selection
    - prove a node while another thread is down that node, can't remove until all threads are back up
      - just don't delete nodes?
  - depth stats

Test
- longer games
- different rave functions
- set a new baseline
- rave extensions

avoid symmetry for the first 3-5 moves, or just build an opening book

detect frames?

prior knowledge
- criticality
- copy knowledge from proof tree
- store knowledge as rave experience instead of real experience?
- size of group

rollout policy
- use weighted random choices instead of uniform random:
- different weights for black vs white?
- local reply?
- locality?
- connections?
- avoid loss
  - use null move to make this equal to force win
  - use locality to stop checking moves that are near nothing
- last-good-reply
  - keep list of moves and their winning replies
  - make the reply if it is valid
  - update the list with replies made this rollout
  - likely needs to the Move structure to allow indexing into an array?


Time control
- quiecense search - if the highest winrate != most played, keep simulating until it is


